<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <title>オセロゲーム</title>
  <!-- React と ReactDOM のCDN -->
  <script crossorigin src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <!-- Babel -->
  <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <style>
    /* アニメーションや基本スタイル */
    @keyframes place-disc {
      0% { transform: translateY(-100px) scale(0.5); opacity: 0; }
      70% { transform: translateY(5px) scale(1.1); opacity: 1; }
      85% { transform: translateY(-3px) scale(0.95); }
      100% { transform: translateY(0) scale(1); }
    }
    
    @keyframes flip-disc {
      0% { transform: rotateY(0deg); }
      50% { transform: rotateY(90deg); }
      100% { transform: rotateY(180deg); }
    }
    
    @keyframes winning-disc {
      0% { transform: scale(1); box-shadow: 0 0 10px 5px rgba(255, 215, 0, 0.3); }
      100% { transform: scale(1.1); box-shadow: 0 0 30px 15px rgba(255, 215, 0, 0.7); }
    }
    
    @keyframes winner-pulse {
      0% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
      50% { transform: scale(1.08); box-shadow: 0 0 30px 15px rgba(255, 215, 0, 0.5); }
      100% { transform: scale(1); box-shadow: 0 0 0 0 rgba(255, 215, 0, 0.7); }
    }
    
    @keyframes float {
      0% { transform: translateY(0) rotate(0deg); }
      100% { transform: translateY(-10px) rotate(5deg); }
    }
    
    @keyframes confetti-fall {
      0% { transform: translateY(0) rotate(0deg); opacity: 1; }
      100% { transform: translateY(100vh) rotate(720deg); opacity: 0; }
    }
    
    @keyframes pop-in {
      0% { transform: scale(0.8); opacity: 0; }
      40% { transform: scale(1.1); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    @keyframes spinner {
      to { transform: rotate(360deg); }
    }
    
    @keyframes pulse {
      0% { background-color: #fffde7; }
      50% { background-color: #fff8e1; }
      100% { background-color: #fffde7; }
    }
    
    @keyframes fade-in {
      from { opacity: 0; }
      to { opacity: 1; }
    }
    
    @keyframes pass-bounce {
      0% { transform: scale(0.5); opacity: 0; }
      50% { transform: scale(1.1); opacity: 1; }
      70% { transform: scale(0.95); opacity: 1; }
      100% { transform: scale(1); opacity: 1; }
    }
    
    /* 新しいアニメーションとスタイル */
    @keyframes elegant-fade-in {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    
    @keyframes elegant-scale {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    @keyframes modern-spinner {
      0% { transform: rotate(0deg); box-shadow: 0 0 0 rgba(98, 0, 234, 0.1); }
      50% { transform: rotate(180deg); box-shadow: 0 0 8px rgba(98, 0, 234, 0.3); }
      100% { transform: rotate(360deg); box-shadow: 0 0 0 rgba(98, 0, 234, 0.1); }
    }
    
    body {
      font-family: 'Segoe UI', 'Helvetica', 'Arial', sans-serif;
      background-color: #f5f7fa;
      margin: 0;
      padding: 0;
      color: #263238;
    }
  </style>
</head>
<body>
  <div id="root"></div>
  <script type="text/babel">
    // ゲーム定数
    const EMPTY = 0;
    const BLACK = 1;
    const WHITE = 2;
    const BOARD_SIZE = 8;
    const DIRECTIONS = [
      [-1, -1], [-1, 0], [-1, 1],
      [0, -1],           [0, 1],
      [1, -1],  [1, 0],  [1, 1]
    ];
    
    // カラースキーム定数
    const PRIMARY = '#6200ea';
    const PRIMARY_LIGHT = '#9d46ff';
    const PRIMARY_DARK = '#0a00b6';
    const ACCENT = '#03dac6';
    const ACCENT_LIGHT = '#66fff8';
    const ACCENT_DARK = '#00a896';
    const WARNING = '#fb8c00';
    const BACKGROUND = '#f5f7fa';
    const SURFACE = '#ffffff';
    const TEXT_PRIMARY = '#263238';
    const TEXT_SECONDARY = '#546e7a';
    const BORDER_RADIUS = '12px';
    const SHADOW_SMALL = '0 2px 8px rgba(0, 0, 0, 0.1)';
    const SHADOW_MEDIUM = '0 4px 12px rgba(0, 0, 0, 0.15)';
    const SHADOW_LARGE = '0 8px 24px rgba(0, 0, 0, 0.2)';
    const TRANSITION_FAST = '0.2s ease';
    const TRANSITION_NORMAL = '0.3s ease';
    const TRANSITION_SLOW = '0.5s ease';
    
    // 初期ボード状態の作成
    const createInitialBoard = () => {
      const board = Array(BOARD_SIZE).fill().map(() => Array(BOARD_SIZE).fill(EMPTY));
      const mid = Math.floor(BOARD_SIZE / 2);
      board[mid-1][mid-1] = WHITE;
      board[mid][mid] = WHITE;
      board[mid-1][mid] = BLACK;
      board[mid][mid-1] = BLACK;
      return board;
    };
    
    const OthelloGame = () => {
      const [board, setBoard] = React.useState(createInitialBoard());
      const [currentPlayer, setCurrentPlayer] = React.useState(BLACK);
      const [validMoves, setValidMoves] = React.useState([]);
      const [scores, setScores] = React.useState({ black: 2, white: 2 });
      const [gameStatus, setGameStatus] = React.useState('playing');
      const [lastMove, setLastMove] = React.useState(null);
      const [flippedDiscs, setFlippedDiscs] = React.useState([]);
      const [animationState, setAnimationState] = React.useState('idle');
      const [winner, setWinner] = React.useState(null);
      const [showHints, setShowHints] = React.useState(true);
      const [animationSpeed, setAnimationSpeed] = React.useState(1);
      const [celebrationActive, setCelebrationActive] = React.useState(false);
      const [showHintsTransition, setShowHintsTransition] = React.useState(true);
      const [gameMode, setGameMode] = React.useState('human-vs-human'); // 'human-vs-human', 'human-vs-computer'
      const [difficulty, setDifficulty] = React.useState('medium'); // 'easy', 'medium', 'hard'
      const [playerColor, setPlayerColor] = React.useState(BLACK);
      const [isComputerThinking, setIsComputerThinking] = React.useState(false);
      const [passAnimationActive, setPassAnimationActive] = React.useState(false);
      const [passedPlayer, setPassedPlayer] = React.useState(null);
      
      // 戦略的な手の選択（難しいレベル用）
      const selectStrategicMove = (moves, gameBoard) => {
        const boardValue = [
          [100, -10, 10,  5,  5, 10, -10, 100],
          [-10, -20,  1,  1,  1,  1, -20, -10],
          [ 10,   1,  5,  2,  2,  5,   1,  10],
          [  5,   1,  2,  1,  1,  2,   1,   5],
          [  5,   1,  2,  1,  1,  2,   1,   5],
          [ 10,   1,  5,  2,  2,  5,   1,  10],
          [-10, -20,  1,  1,  1,  1, -20, -10],
          [100, -10, 10,  5,  5, 10, -10, 100]
        ];
        return moves.reduce((best, move) => {
          const value = boardValue[move.row][move.col] + move.flips.length * 2;
          return value > best.value ? { ...move, value } : best;
        }, { ...moves[0], value: boardValue[moves[0].row][moves[0].col] + moves[0].flips.length * 2 });
      };
      
      // 有効な手を計算
      const calculateValidMoves = React.useCallback((gameBoard, player) => {
        const moves = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            if (gameBoard[row][col] !== EMPTY) continue;
            const flips = getFlippedDiscs(gameBoard, row, col, player);
            if (flips.length > 0) {
              moves.push({ row, col, flips });
            }
          }
        }
        return moves;
      }, []);
      
      // 反転するディスクを取得
      const getFlippedDiscs = (gameBoard, row, col, player) => {
        const opponent = player === BLACK ? WHITE : BLACK;
        const flips = [];
        DIRECTIONS.forEach(([dx, dy]) => {
          let x = row + dx;
          let y = col + dy;
          const temp = [];
          while (
            x >= 0 && x < BOARD_SIZE &&
            y >= 0 && y < BOARD_SIZE &&
            gameBoard[x][y] === opponent
          ) {
            temp.push({ row: x, col: y });
            x += dx;
            y += dy;
          }
          if (
            temp.length > 0 &&
            x >= 0 && x < BOARD_SIZE &&
            y >= 0 && y < BOARD_SIZE &&
            gameBoard[x][y] === player
          ) {
            flips.push(...temp);
          }
        });
        return flips;
      };
      
      // スコアの計算
      const calculateScores = (gameBoard) => {
        let black = 0, white = 0;
        for (let row = 0; row < BOARD_SIZE; row++) {
          for (let col = 0; col < BOARD_SIZE; col++) {
            if (gameBoard[row][col] === BLACK) black++;
            else if (gameBoard[row][col] === WHITE) white++;
          }
        }
        return { black, white };
      };
      
      // ゲームの終了チェック
      const checkGameEnd = (blackMoves, whiteMoves) => {
        if (blackMoves.length === 0 && whiteMoves.length === 0) {
          const { black, white } = scores;
          let gameWinner = null;
          if (black > white) gameWinner = BLACK;
          else if (white > black) gameWinner = WHITE;
          setGameStatus('ended');
          setWinner(gameWinner);
          setTimeout(() => {
            setCelebrationActive(true);
          }, 500);
          return true;
        }
        return false;
      };
      
      // プレイヤーの交代
      const switchPlayer = React.useCallback((blackMoves, whiteMoves) => {
        const nextPlayer = currentPlayer === BLACK ? WHITE : BLACK;
        setShowHintsTransition(false);
        if ((nextPlayer === BLACK && blackMoves.length === 0) ||
            (nextPlayer === WHITE && whiteMoves.length === 0)) {
          setCurrentPlayer(currentPlayer);
        } else {
          setCurrentPlayer(nextPlayer);
        }
        setTimeout(() => {
          setShowHintsTransition(true);
        }, 300 / animationSpeed);
      }, [currentPlayer, animationSpeed]);
      
      // ディスクを置いた後の処理
      const afterPlacingDisc = React.useCallback((move, player, gameBoard) => {
        if (!move || !move.flips || !Array.isArray(move.flips) || move.flips.length === 0) {
          console.error('Invalid move or flips:', move);
          return;
        }
        setLastMove({ row: move.row, col: move.col });
        setAnimationState('placing');
        const newBoard = [...gameBoard.map(r => [...r])];
        newBoard[move.row][move.col] = player;
        setBoard(newBoard);
        setTimeout(() => {
          setAnimationState('flipping');
          setFlippedDiscs(move.flips);
          setTimeout(() => {
            const finalBoard = [...newBoard.map(r => [...r])];
            move.flips.forEach(({ row, col }) => {
              finalBoard[row][col] = player;
            });
            setBoard(finalBoard);
            setTimeout(() => {
              const newScores = calculateScores(finalBoard);
              setScores(newScores);
              const blackMoves = calculateValidMoves(finalBoard, BLACK);
              const whiteMoves = calculateValidMoves(finalBoard, WHITE);
              if (!checkGameEnd(blackMoves, whiteMoves)) {
                switchPlayer(blackMoves, whiteMoves);
              }
              setAnimationState('idle');
              setFlippedDiscs([]);
            }, 300 / animationSpeed);
          }, 300 / animationSpeed);
        }, 300 / animationSpeed);
      }, [calculateValidMoves, switchPlayer, animationSpeed]);
      
      // CPUの手を選んで実行する
      const executeComputerTurn = React.useCallback(() => {
        if (gameStatus !== 'playing' ||
            gameMode !== 'human-vs-computer' ||
            currentPlayer === playerColor ||
            validMoves.length === 0 ||
            isComputerThinking ||
            passAnimationActive) {
          return;
        }
        setIsComputerThinking(true);
        setTimeout(() => {
          let selectedMove;
          if (difficulty === 'easy') {
            selectedMove = validMoves[Math.floor(Math.random() * validMoves.length)];
          } else if (difficulty === 'medium') {
            selectedMove = validMoves.reduce((best, move) =>
              move.flips.length > best.flips.length ? move : best,
              validMoves[0]
            );
          } else {
            selectedMove = selectStrategicMove(validMoves, board);
          }
          if (selectedMove) {
            const freshFlips = getFlippedDiscs(board, selectedMove.row, selectedMove.col, currentPlayer);
            if (freshFlips.length === 0) {
              const currentValidMoves = calculateValidMoves(board, currentPlayer);
              if (currentValidMoves.length > 0) {
                if (difficulty === 'easy') {
                  selectedMove = currentValidMoves[Math.floor(Math.random() * currentValidMoves.length)];
                } else if (difficulty === 'medium') {
                  selectedMove = currentValidMoves.reduce((best, move) =>
                    move.flips.length > best.flips.length ? move : best,
                    currentValidMoves[0]
                  );
                } else {
                  selectedMove = selectStrategicMove(currentValidMoves, board);
                }
              } else {
                setIsComputerThinking(false);
                return;
              }
            } else {
              selectedMove = { ...selectedMove, flips: freshFlips };
            }
          }
          setIsComputerThinking(false);
          if (selectedMove) {
            afterPlacingDisc(selectedMove, currentPlayer, board);
          }
        }, 1000);
      }, [
        gameStatus, gameMode, currentPlayer, playerColor, validMoves,
        isComputerThinking, passAnimationActive, difficulty, board,
        afterPlacingDisc, calculateValidMoves
      ]);
      
      // セルをクリックした時の処理
      const handleCellClick = React.useCallback((row, col) => {
        if (gameStatus !== 'playing' ||
            animationState !== 'idle' ||
            gameMode === 'computer-vs-computer' ||
            (gameMode === 'human-vs-computer' && currentPlayer !== playerColor)) {
          return;
        }
        const move = validMoves.find(m => m.row === row && m.col === col);
        if (!move) return;
        afterPlacingDisc(move, currentPlayer, board);
      }, [
        gameStatus, animationState, gameMode, currentPlayer, playerColor, validMoves, board, afterPlacingDisc
      ]);
      
      // パスの処理
      const handlePass = React.useCallback(() => {
        if (gameStatus !== 'playing') return;
        console.log('パス処理を実行します', currentPlayer === BLACK ? '黒' : '白');
        setPassedPlayer(currentPlayer);
        setPassAnimationActive(true);
        setTimeout(() => {
          const nextPlayer = currentPlayer === BLACK ? WHITE : BLACK;
          const nextMoves = calculateValidMoves(board, nextPlayer);
          if (nextMoves.length === 0) {
            checkGameEnd([], []);
          } else {
            setCurrentPlayer(nextPlayer);
          }
          setTimeout(() => {
            console.log('パス表示を終了します');
            setPassAnimationActive(false);
          }, 700);
        }, 700);
      }, [gameStatus, currentPlayer, board, calculateValidMoves, checkGameEnd]);
      
      // ゲームのリセット
      const resetGame = React.useCallback(() => {
        setBoard(createInitialBoard());
        setCurrentPlayer(BLACK);
        setScores({ black: 2, white: 2 });
        setGameStatus('playing');
        setLastMove(null);
        setFlippedDiscs([]);
        setAnimationState('idle');
        setWinner(null);
        setCelebrationActive(false);
        setShowHintsTransition(true);
        setIsComputerThinking(false);
        setPassAnimationActive(false);
        setPassedPlayer(null);
      }, []);
      
      // ゲーム状態の監視
      React.useEffect(() => {
        // アニメーションが完了している状態のみチェックする
        if (gameStatus === 'playing' && animationState === 'idle') {
          const moves = calculateValidMoves(board, currentPlayer);
          setValidMoves(moves);
          if (moves.length === 0 && !passAnimationActive &&
              (gameMode !== 'human-vs-computer' || currentPlayer === playerColor)) {
            // タイマーによる遅延をなくして即座にパス処理を実行する
            handlePass();
          }
        }
      }, [
        board,
        currentPlayer,
        gameStatus,
        animationState, // 追加
        calculateValidMoves,
        handlePass,
        passAnimationActive,
        gameMode,
        playerColor
      ]);

      
      React.useEffect(() => {
        resetGame();
      }, [gameMode, playerColor, resetGame]);
      
      React.useEffect(() => {
        if (animationState === 'idle' &&
            gameStatus === 'playing' &&
            !passAnimationActive &&
            gameMode === 'human-vs-computer' &&
            currentPlayer !== playerColor) {
          if (validMoves.length === 0) {
            console.log('CPUには有効な手がありません。パスします。');
            handlePass();
          } else {
            executeComputerTurn();
          }
        }
      }, [animationState, gameStatus, passAnimationActive, gameMode, currentPlayer, playerColor, validMoves, executeComputerTurn, handlePass]);
      
      // レンダリング関数群
      
      const renderCell = (row, col) => {
        const cellValue = board[row][col];
        const isValid = validMoves.some(move => move.row === row && move.col === col);
        const isLastMove = lastMove && lastMove.row === row && lastMove.col === col;
        const isFlipped = flippedDiscs.some(disc => disc.row === row && disc.col === col);
        const isWinningDisc = gameStatus === 'ended' && winner && cellValue === winner;
        const cellStyle = {
          width: '60px',
          height: '60px',
          background: isLastMove ? '#3498db' : '#27ae60',
          border: '1px solid rgba(0, 0, 0, 0.1)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          position: 'relative',
          cursor: 'pointer',
          overflow: 'hidden'
        };
        const discStyle = {
          width: '45px',
          height: '45px',
          borderRadius: '50%',
          boxShadow: '0 3px 5px rgba(0, 0, 0, 0.3)',
          position: 'relative',
          transition: 'transform 0.3s, box-shadow 0.3s',
          background: cellValue === BLACK 
            ? 'linear-gradient(135deg, #333 0%, #000 100%)'
            : 'linear-gradient(135deg, #fff 0%, #e6e6e6 100%)',
          border: cellValue === BLACK ? '2px solid #111' : '2px solid #ccc',
          animation: isLastMove && animationState === 'placing' 
            ? 'place-disc 0.5s ease-out'
            : isFlipped && animationState === 'flipping'
              ? 'flip-disc 0.5s ease-in-out'
              : isWinningDisc && celebrationActive
                ? 'winning-disc 1.5s infinite alternate'
                : ''
        };
        const hintStyle = {
          position: 'absolute',
          width: '20px',
          height: '20px',
          borderRadius: '50%',
          opacity: 0.5,
          pointerEvents: 'none',
          transition: 'opacity 0.15s ease-in',
          background: currentPlayer === BLACK ? '#000' : '#fff'
        };
        return (
          <div key={`${row}-${col}`} style={cellStyle} onClick={() => handleCellClick(row, col)}>
            {cellValue !== EMPTY && (<div style={discStyle} />)}
            {isValid && showHints && animationState === 'idle' && showHintsTransition && (<div style={hintStyle} />)}
          </div>
        );
      };
      
      const renderBoard = () => {
        const rows = [];
        for (let row = 0; row < BOARD_SIZE; row++) {
          const cols = [];
          for (let col = 0; col < BOARD_SIZE; col++) {
            cols.push(renderCell(row, col));
          }
          rows.push(<div key={row} style={{ display: 'flex' }}>{cols}</div>);
        }
        const boardStyle = {
          display: 'flex',
          flexDirection: 'column',
          background: '#2c3e50',
          border: '10px solid #34495e',
          borderRadius: '8px',
          boxShadow: '0 10px 20px rgba(0, 0, 0, 0.2)',
          position: 'relative',
          overflow: 'hidden'
        };
        return (<div style={boardStyle}>{rows}</div>);
      };
      
      const renderGameInfo = () => {
        const gameInfoStyle = {
          display: 'flex',
          flexDirection: 'column',
          gap: '1.5rem',
          minWidth: '320px',
          background: SURFACE,
          padding: '1.8rem',
          borderRadius: BORDER_RADIUS,
          boxShadow: SHADOW_MEDIUM,
          marginTop: '0',
          animation: `elegant-fade-in ${TRANSITION_NORMAL}`,
          border: '1px solid rgba(0, 0, 0, 0.05)'
        };
        
        const scoresStyle = {
          display: 'flex',
          justifyContent: 'space-between',
          gap: '1rem',
          marginBottom: '0.5rem'
        };
        
        const getScoreStyle = (player) => ({
          display: 'flex',
          alignItems: 'center',
          gap: '0.7rem',
          padding: '0.8rem 1.2rem',
          borderRadius: BORDER_RADIUS,
          transition: `all ${TRANSITION_FAST}`,
          background: currentPlayer === player 
            ? `linear-gradient(135deg, ${PRIMARY_LIGHT}, ${PRIMARY})`
            : BACKGROUND,
          transform: currentPlayer === player ? 'scale(1.05)' : 'scale(1)',
          boxShadow: currentPlayer === player ? SHADOW_SMALL : 'none',
          flex: 1,
          justifyContent: 'center'
        });
        
        const discStyle = (color) => ({
          width: '32px',
          height: '32px',
          borderRadius: '50%',
          background: color === BLACK 
            ? 'linear-gradient(135deg, #333 0%, #000 100%)'
            : 'linear-gradient(135deg, #fff 0%, #e6e6e6 100%)',
          border: color === BLACK ? '2px solid #111' : '2px solid #ccc',
          boxShadow: '0 2px 4px rgba(0, 0, 0, 0.2)'
        });
        
        const statusStyle = {
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '0.8rem',
          padding: '1.2rem',
          background: BACKGROUND,
          borderRadius: BORDER_RADIUS,
          margin: '0.5rem 0'
        };
        
        const turnResultStyle = {
          display: 'flex',
          alignItems: 'center',
          gap: '1rem',
          fontSize: '1.3rem',
          fontWeight: '600',
          color: TEXT_PRIMARY
        };
        
        const buttonStyle = {
          background: `linear-gradient(135deg, ${PRIMARY}, ${PRIMARY_DARK})`,
          color: 'white',
          border: 'none',
          padding: '0.9rem 1.5rem',
          fontSize: '1rem',
          fontWeight: '600',
          borderRadius: BORDER_RADIUS,
          cursor: 'pointer',
          transition: `all ${TRANSITION_FAST}`,
          boxShadow: SHADOW_SMALL,
          textAlign: 'center',
          width: '100%',
          marginBottom: '0.5rem'
        };
        
        const controlsContainerStyle = {
          display: 'flex',
          flexDirection: 'column',
          gap: '1rem',
          padding: '1.2rem',
          background: BACKGROUND,
          borderRadius: BORDER_RADIUS,
        };
        
        const controlLabelStyle = {
          display: 'flex',
          alignItems: 'center',
          gap: '0.7rem',
          cursor: 'pointer',
          padding: '0.5rem',
          borderRadius: '4px',
          transition: `background ${TRANSITION_FAST}`,
          color: TEXT_PRIMARY
        };
        
        const selectStyle = {
          padding: '0.6rem 0.8rem',
          borderRadius: '8px',
          border: '1px solid rgba(0, 0, 0, 0.1)',
          background: 'white',
          fontSize: '0.9rem',
          color: TEXT_PRIMARY,
          width: '100%',
          cursor: 'pointer',
          marginTop: '0.3rem'
        };
        
        return (
          <div style={gameInfoStyle}>
            <div style={{
              borderBottom: '1px solid rgba(0, 0, 0, 0.05)',
              paddingBottom: '0.5rem',
              marginBottom: '0.5rem'
            }}>
              <h2 style={{
                margin: 0,
                fontSize: '1.4rem',
                fontWeight: '600',
                color: PRIMARY,
                textAlign: 'center'
              }}>
                ゲーム情報
              </h2>
            </div>
            
            <div style={scoresStyle}>
              <div style={getScoreStyle(BLACK)}>
                <div style={discStyle(BLACK)} />
                <span style={{ 
                  fontSize: '1.5rem', 
                  fontWeight: 'bold', 
                  color: currentPlayer === BLACK ? 'white' : TEXT_PRIMARY
                }}>
                  {scores.black}
                </span>
              </div>
              <div style={getScoreStyle(WHITE)}>
                <div style={discStyle(WHITE)} />
                <span style={{ 
                  fontSize: '1.5rem', 
                  fontWeight: 'bold', 
                  color: currentPlayer === WHITE ? 'white' : TEXT_PRIMARY
                }}>
                  {scores.white}
                </span>
              </div>
            </div>
            
            <div style={statusStyle}>
              {gameStatus === 'playing' ? (
                <div style={turnResultStyle}>
                  <span>ターン:</span>
                  <div style={{
                    ...discStyle(currentPlayer),
                    animation: 'elegant-scale 2s infinite'
                  }} />
                </div>
              ) : (
                <div style={turnResultStyle}>
                  {winner ? (
                    <>
                      <span>勝者:</span>
                      <div style={discStyle(winner)} />
                    </>
                  ) : (
                    <span>引き分け</span>
                  )}
                </div>
              )}
            </div>
            
            <div style={controlsContainerStyle}>
              <button 
                style={buttonStyle} 
                onClick={resetGame}
                onMouseOver={(e) => {
                  e.currentTarget.style.transform = 'translateY(-2px)';
                  e.currentTarget.style.boxShadow = SHADOW_MEDIUM;
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.transform = 'translateY(0)';
                  e.currentTarget.style.boxShadow = SHADOW_SMALL;
                }}
              >
                リセット
              </button>
              
              <label style={controlLabelStyle}>
                <input 
                  type="checkbox" 
                  checked={showHints} 
                  onChange={() => setShowHints(!showHints)}
                  style={{
                    width: '18px',
                    height: '18px',
                    accentColor: PRIMARY
                  }} 
                />
                <span>ヒントを表示</span>
              </label>
              
              <div style={{ marginTop: '0.5rem' }}>
                <label style={{ 
                  fontSize: '0.9rem', 
                  color: TEXT_SECONDARY,
                  marginBottom: '0.3rem',
                  display: 'block'
                }}>
                  アニメーション速度:
                </label>
                <select
                  value={animationSpeed}
                  onChange={(e) => setAnimationSpeed(Number(e.target.value))}
                  style={selectStyle}
                >
                  <option value={0.5}>遅い</option>
                  <option value={1}>通常</option>
                  <option value={2}>速い</option>
                </select>
              </div>
            </div>
          </div>
        );
      };
      
      const renderNoMoves = () => {
        if (gameStatus === 'playing' && validMoves.length === 0) {
          const noMovesStyle = {
            display: 'flex',
            alignItems: 'center',
            gap: '0.8rem',
            background: 'linear-gradient(135deg, #ffe8e8, #ffcdd2)',
            color: '#c62828',
            padding: '1rem 1.2rem',
            borderRadius: BORDER_RADIUS,
            marginTop: '1rem',
            animation: `elegant-fade-in ${TRANSITION_NORMAL}`,
            boxShadow: SHADOW_SMALL,
            border: '1px solid rgba(198, 40, 40, 0.2)'
          };
          
          return (
            <div style={noMovesStyle}>
              <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
                <circle cx="12" cy="12" r="10"></circle>
                <line x1="12" y1="8" x2="12" y2="12"></line>
                <line x1="12" y1="16" x2="12.01" y2="16"></line>
              </svg>
              <span style={{
                fontWeight: '500'
              }}>
                打てる場所がありません。パスします。
              </span>
            </div>
          );
        }
        return null;
      };
      
      const renderGameResult = () => {
        if (gameStatus !== 'ended') return null;
        
        const gameResultStyle = {
          position: 'fixed',
          top: 0,
          left: 0,
          width: '100%',
          height: '100%',
          background: 'rgba(0, 0, 0, 0.85)',
          display: 'flex',
          justifyContent: 'center',
          alignItems: 'center',
          zIndex: 100,
          opacity: celebrationActive ? 1 : 0,
          pointerEvents: celebrationActive ? 'all' : 'none',
          transition: 'opacity 0.5s',
          backdropFilter: 'blur(8px)'
        };
        
        const resultContentStyle = {
          background: 'white',
          padding: '2.5rem',
          borderRadius: '24px',
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          gap: '1.8rem',
          boxShadow: '0 0 50px rgba(255, 255, 255, 0.2)',
          transform: celebrationActive ? 'scale(1)' : 'scale(0.9)',
          transition: 'transform 0.5s',
          maxWidth: '450px',
          width: '85%',
          textAlign: 'center',
          animation: celebrationActive ? 'pop-in 0.7s ease-out' : '',
          border: '1px solid rgba(255, 255, 255, 0.1)'
        };
        
        const winnerDiscStyle = {
          width: '120px',
          height: '120px',
          borderRadius: '50%',
          margin: '1rem 0',
          animation: 'winner-pulse 2s infinite',
          background: winner === BLACK 
            ? 'linear-gradient(135deg, #333 0%, #000 100%)'
            : 'linear-gradient(135deg, #fff 0%, #e6e6e6 100%)',
          border: winner === BLACK ? '4px solid #333' : '4px solid #ddd',
          boxShadow: winner === BLACK 
            ? '0 0 40px rgba(0, 0, 0, 0.8)'
            : '0 0 40px rgba(255, 255, 255, 0.9)'
        };
        
        const playAgainButtonStyle = {
          background: `linear-gradient(135deg, ${PRIMARY}, ${PRIMARY_DARK})`,
          color: 'white',
          border: 'none',
          padding: '1.2rem 2.5rem',
          fontSize: '1.3rem',
          fontWeight: '600',
          borderRadius: '50px',
          cursor: 'pointer',
          transition: `all ${TRANSITION_FAST}`,
          boxShadow: SHADOW_MEDIUM,
          marginTop: '1rem',
          position: 'relative',
          overflow: 'hidden',
          zIndex: 1
        };
        
        return (
          <div style={gameResultStyle}>
            <div style={resultContentStyle}>
              <h2 style={{ 
                fontSize: '2.2rem', 
                fontWeight: '800', 
                color: PRIMARY, 
                margin: 0, 
                fontFamily: "'Segoe UI', sans-serif"
              }}>
                ゲーム終了
              </h2>
              
              {winner ? (
                <>
                  <p style={{ 
                    fontSize: '3rem', 
                    fontWeight: '800', 
                    background: `linear-gradient(45deg, ${PRIMARY}, ${ACCENT})`,
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                    margin: 0,
                    padding: '0.5rem 0',
                    letterSpacing: '1px'
                  }}>
                    勝者
                  </p>
                  <div style={winnerDiscStyle} />
                  <p style={{ 
                    fontSize: '1.5rem', 
                    color: TEXT_SECONDARY, 
                    margin: 0, 
                    fontWeight: '600' 
                  }}>
                    黒: {scores.black} / 白: {scores.white}
                  </p>
                </>
              ) : (
                <>
                  <p style={{ 
                    fontSize: '3rem', 
                    fontWeight: '800', 
                    background: `linear-gradient(45deg, ${PRIMARY}, ${ACCENT})`,
                    WebkitBackgroundClip: 'text',
                    WebkitTextFillColor: 'transparent',
                    margin: 0,
                    padding: '0.5rem 0',
                    letterSpacing: '1px'
                  }}>
                    引き分け
                  </p>
                  <div style={{ 
                    display: 'flex', 
                    gap: '2rem', 
                    margin: '1rem 0',
                    justifyContent: 'center'
                  }}>
                    <div style={{
                      width: '80px',
                      height: '80px',
                      borderRadius: '50%',
                      background: 'linear-gradient(135deg, #333 0%, #000 100%)',
                      border: '4px solid #333',
                      boxShadow: '0 0 20px rgba(0, 0, 0, 0.6)',
                      animation: 'float 3s infinite alternate'
                    }} />
                    <div style={{
                      width: '80px',
                      height: '80px',
                      borderRadius: '50%',
                      background: 'linear-gradient(135deg, #fff 0%, #e6e6e6 100%)',
                      border: '4px solid #ddd',
                      boxShadow: '0 0 20px rgba(255, 255, 255, 0.8)',
                      animation: 'float 3s infinite alternate-reverse'
                    }} />
                  </div>
                  <p style={{ 
                    fontSize: '1.5rem', 
                    color: TEXT_SECONDARY, 
                    margin: 0, 
                    fontWeight: '600' 
                  }}>
                    黒: {scores.black} / 白: {scores.white}
                  </p>
                </>
              )}
              
              <button 
                style={playAgainButtonStyle} 
                onClick={resetGame}
                onMouseOver={(e) => {
                  e.currentTarget.style.transform = 'translateY(-3px)';
                  e.currentTarget.style.boxShadow = SHADOW_LARGE;
                }}
                onMouseOut={(e) => {
                  e.currentTarget.style.transform = 'translateY(0)';
                  e.currentTarget.style.boxShadow = SHADOW_MEDIUM;
                }}
              >
                もう一度プレイ
              </button>
            </div>
            
            {winner && celebrationActive && (
              <div style={{
                position: 'absolute',
                top: 0,
                left: 0,
                width: '100%',
                height: '100%',
                pointerEvents: 'none',
                overflow: 'hidden',
                zIndex: -1
              }}>
                {Array.from({ length: 70 }).map((_, i) => {
                  const size = 5 + Math.random() * 15;
                  return (
                    <div 
                      key={i}
                      style={{
                        position: 'absolute',
                        width: `${size}px`,
                        height: `${size}px`,
                        borderRadius: Math.random() > 0.5 ? '50%' : '0',
                        top: '-20px',
                        left: `${Math.random() * 100}%`,
                        opacity: 0.8,
                        animation: `confetti-fall ${3 + Math.random() * 7}s linear forwards`,
                        animationDelay: `${Math.random() * 3}s`,
                        backgroundColor: winner === BLACK 
                          ? i % 3 === 0 
                            ? PRIMARY 
                            : i % 3 === 1 
                              ? PRIMARY_LIGHT 
                              : `hsl(0, 0%, ${Math.floor(Math.random() * 60)}%)`
                          : i % 3 === 0 
                            ? ACCENT 
                            : i % 3 === 1 
                              ? ACCENT_LIGHT 
                              : `hsl(0, 0%, ${Math.floor(60 + Math.random() * 40)}%)`
                      }}
                    />
                  );
                })}
              </div>
            )}
          </div>
        );
      };
      
      const renderGameModeSelector = () => {
        const gameModeContainerStyle = {
          background: SURFACE,
          borderRadius: BORDER_RADIUS,
          padding: '2rem',
          marginBottom: '2.5rem',
          boxShadow: SHADOW_MEDIUM,
          display: 'flex',
          flexWrap: 'wrap',
          gap: '2.5rem',
          justifyContent: 'center',
          width: '100%',
          maxWidth: '850px',
          border: '1px solid rgba(0, 0, 0, 0.05)',
          animation: `elegant-fade-in ${TRANSITION_NORMAL}`
        };
        
        const sectionStyle = {
          minWidth: '230px',
          flex: '1'
        };
        
        const sectionTitleStyle = {
          marginTop: 0,
          marginBottom: '1.2rem',
          color: PRIMARY,
          fontSize: '1.2rem',
          fontWeight: '600',
          borderBottom: `2px solid ${PRIMARY_LIGHT}`,
          paddingBottom: '0.5rem',
          display: 'inline-block'
        };
        
        const radioGroupStyle = {
          display: 'flex',
          flexDirection: 'column',
          gap: '1rem'
        };
        
        const radioLabelStyle = {
          display: 'flex',
          alignItems: 'center',
          gap: '0.7rem',
          cursor: 'pointer',
          padding: '0.7rem 1rem',
          borderRadius: '8px',
          transition: `all ${TRANSITION_FAST}`,
          background: 'rgba(0, 0, 0, 0.02)'
        };
        
        const selectStyle = {
          padding: '0.8rem 1rem',
          borderRadius: '10px',
          border: '1px solid rgba(0, 0, 0, 0.1)',
          fontSize: '1rem',
          width: '100%',
          cursor: 'pointer',
          background: 'white',
          boxShadow: '0 2px 4px rgba(0, 0, 0, 0.05)',
          transition: `all ${TRANSITION_FAST}`
        };
        
        const playerColorSelectorStyle = {
          display: 'flex',
          gap: '1.2rem',
          flexWrap: 'wrap',
          justifyContent: 'center',
          marginTop: '0.5rem'
        };
        
        const getColorOptionStyle = (color) => ({
          display: 'flex',
          alignItems: 'center',
          gap: '0.8rem',
          padding: '0.8rem 1.2rem',
          borderRadius: '10px',
          cursor: 'pointer',
          border: '2px solid',
          borderColor: playerColor === color 
            ? PRIMARY 
            : 'rgba(0, 0, 0, 0.1)',
          background: playerColor === color 
            ? `linear-gradient(135deg, ${PRIMARY_LIGHT}20, ${PRIMARY}10)` 
            : 'white',
          transition: `all ${TRANSITION_FAST}`,
          boxShadow: playerColor === color 
            ? SHADOW_SMALL 
            : 'none',
          transform: playerColor === color 
            ? 'translateY(-2px)' 
            : 'none'
        });
        
        const colorDiscStyle = (color) => ({
          width: '30px',
          height: '30px',
          borderRadius: '50%',
          background: color === BLACK 
            ? 'linear-gradient(135deg, #333 0%, #000 100%)'
            : 'linear-gradient(135deg, #fff 0%, #e6e6e6 100%)',
          border: color === BLACK ? '2px solid #111' : '2px solid #ccc',
          boxShadow: '0 3px 6px rgba(0, 0, 0, 0.2)'
        });
        
        return (
          <div style={gameModeContainerStyle}>
            <div style={sectionStyle}>
              <h3 style={sectionTitleStyle}>ゲームモード</h3>
              <div style={radioGroupStyle}>
                <label 
                  style={{
                    ...radioLabelStyle,
                    background: gameMode === 'human-vs-human' 
                      ? `linear-gradient(135deg, ${PRIMARY_LIGHT}15, ${PRIMARY}05)` 
                      : 'rgba(0, 0, 0, 0.02)',
                    border: gameMode === 'human-vs-human' 
                      ? `1px solid ${PRIMARY}30` 
                      : '1px solid transparent'
                  }}
                  onMouseOver={(e) => {
                    if (gameMode !== 'human-vs-human') {
                      e.currentTarget.style.background = 'rgba(0, 0, 0, 0.04)';
                    }
                  }}
                  onMouseOut={(e) => {
                    if (gameMode !== 'human-vs-human') {
                      e.currentTarget.style.background = 'rgba(0, 0, 0, 0.02)';
                    }
                  }}
                >
                  <input
                    type="radio"
                    value="human-vs-human"
                    checked={gameMode === 'human-vs-human'}
                    onChange={(e) => setGameMode(e.target.value)}
                    style={{ 
                      width: '18px', 
                      height: '18px',
                      accentColor: PRIMARY 
                    }}
                  />
                  <span style={{ 
                    fontWeight: gameMode === 'human-vs-human' ? '500' : 'normal' 
                  }}>
                    対人プレイ
                  </span>
                </label>
                <label 
                  style={{
                    ...radioLabelStyle,
                    background: gameMode === 'human-vs-computer' 
                      ? `linear-gradient(135deg, ${PRIMARY_LIGHT}15, ${PRIMARY}05)` 
                      : 'rgba(0, 0, 0, 0.02)',
                    border: gameMode === 'human-vs-computer' 
                      ? `1px solid ${PRIMARY}30` 
                      : '1px solid transparent'
                  }}
                  onMouseOver={(e) => {
                    if (gameMode !== 'human-vs-computer') {
                      e.currentTarget.style.background = 'rgba(0, 0, 0, 0.04)';
                    }
                  }}
                  onMouseOut={(e) => {
                    if (gameMode !== 'human-vs-computer') {
                      e.currentTarget.style.background = 'rgba(0, 0, 0, 0.02)';
                    }
                  }}
                >
                  <input
                    type="radio"
                    value="human-vs-computer"
                    checked={gameMode === 'human-vs-computer'}
                    onChange={(e) => setGameMode(e.target.value)}
                    style={{ 
                      width: '18px', 
                      height: '18px',
                      accentColor: PRIMARY 
                    }}
                  />
                  <span style={{ 
                    fontWeight: gameMode === 'human-vs-computer' ? '500' : 'normal' 
                  }}>
                    CPUと対戦
                  </span>
                </label>
              </div>
            </div>
            
            {gameMode === 'human-vs-computer' && (
              <>
                <div style={sectionStyle}>
                  <h3 style={sectionTitleStyle}>難易度</h3>
                  <select
                    value={difficulty}
                    onChange={(e) => setDifficulty(e.target.value)}
                    style={selectStyle}
                    onFocus={(e) => {
                      e.currentTarget.style.boxShadow = `0 0 0 3px ${PRIMARY}30`;
                      e.currentTarget.style.borderColor = PRIMARY;
                    }}
                    onBlur={(e) => {
                      e.currentTarget.style.boxShadow = '0 2px 4px rgba(0, 0, 0, 0.05)';
                      e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.1)';
                    }}
                  >
                    <option value="easy">かんたん</option>
                    <option value="medium">ふつう</option>
                    <option value="hard">むずかしい</option>
                  </select>
                </div>
                
                <div style={sectionStyle}>
                  <h3 style={sectionTitleStyle}>プレイヤーの色</h3>
                  <div style={playerColorSelectorStyle}>
                    <label 
                      style={getColorOptionStyle(BLACK)}
                      onMouseOver={(e) => {
                        if (playerColor !== BLACK) {
                          e.currentTarget.style.transform = 'translateY(-2px)';
                          e.currentTarget.style.boxShadow = SHADOW_SMALL;
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                        }
                      }}
                      onMouseOut={(e) => {
                        if (playerColor !== BLACK) {
                          e.currentTarget.style.transform = 'none';
                          e.currentTarget.style.boxShadow = 'none';
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.1)';
                        }
                      }}
                    >
                      <input
                        type="radio"
                        name="player-color"
                        checked={playerColor === BLACK}
                        onChange={() => setPlayerColor(BLACK)}
                        style={{ opacity: 0, position: 'absolute' }}
                      />
                      <div style={colorDiscStyle(BLACK)} />
                      <span style={{ fontWeight: playerColor === BLACK ? '500' : 'normal' }}>
                        黒（先手）
                      </span>
                    </label>
                    
                    <label 
                      style={getColorOptionStyle(WHITE)}
                      onMouseOver={(e) => {
                        if (playerColor !== WHITE) {
                          e.currentTarget.style.transform = 'translateY(-2px)';
                          e.currentTarget.style.boxShadow = SHADOW_SMALL;
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.2)';
                        }
                      }}
                      onMouseOut={(e) => {
                        if (playerColor !== WHITE) {
                          e.currentTarget.style.transform = 'none';
                          e.currentTarget.style.boxShadow = 'none';
                          e.currentTarget.style.borderColor = 'rgba(0, 0, 0, 0.1)';
                        }
                      }}
                    >
                      <input
                        type="radio"
                        name="player-color"
                        checked={playerColor === WHITE}
                        onChange={() => setPlayerColor(WHITE)}
                        style={{ opacity: 0, position: 'absolute' }}
                      />
                      <div style={colorDiscStyle(WHITE)} />
                      <span style={{ fontWeight: playerColor === WHITE ? '500' : 'normal' }}>
                        白（後手）
                      </span>
                    </label>
                  </div>
                </div>
              </>
            )}
          </div>
        );
      };
      
      const renderThinkingIndicator = () => {
        if (isComputerThinking && gameStatus === 'playing') {
          const thinkingStyle = {
            display: 'flex',
            alignItems: 'center',
            gap: '1rem',
            background: `linear-gradient(135deg, ${PRIMARY_LIGHT}15, ${PRIMARY}05)`,
            color: PRIMARY,
            padding: '1rem 1.2rem',
            borderRadius: BORDER_RADIUS,
            marginTop: '1rem',
            boxShadow: SHADOW_SMALL,
            border: `1px solid ${PRIMARY}30`,
            animation: `elegant-fade-in ${TRANSITION_NORMAL}`
          };
          
          const spinnerStyle = {
            width: '24px',
            height: '24px',
            border: `3px solid ${PRIMARY}30`,
            borderTopColor: PRIMARY,
            borderRadius: '50%',
            animation: 'modern-spinner 1.2s infinite linear'
          };
          
          return (
            <div style={thinkingStyle}>
              <div style={spinnerStyle} />
              <span style={{ fontWeight: '500' }}>CPUが考え中...</span>
            </div>
          );
        }
        return null;
      };
      
      const renderPassAnimation = () => {
        if (!passAnimationActive) return null;
        
        return (
          <div
            style={{
              position: 'fixed',
              top: 0,
              left: 0,
              width: '100%',
              height: '100%',
              display: 'flex',
              justifyContent: 'center',
              alignItems: 'center',
              background: 'rgba(0, 0, 0, 0.8)',
              backdropFilter: 'blur(8px)',
              zIndex: 1000,
              animation: `elegant-fade-in ${TRANSITION_NORMAL}`
            }}
          >
            <div
              style={{
                background: passedPlayer === BLACK ? 
                  'linear-gradient(135deg, #333, #000)' : 
                  'linear-gradient(135deg, #fff, #f0f0f0)',
                color: passedPlayer === BLACK ? 'white' : 'black',
                padding: '2.5rem 4rem',
                borderRadius: '20px',
                textAlign: 'center',
                boxShadow: '0 0 40px rgba(255, 255, 255, 0.2)',
                borderWidth: '4px',
                borderStyle: 'solid',
                borderColor: passedPlayer === BLACK ? 
                  'rgba(255, 255, 255, 0.1)' : 
                  'rgba(0, 0, 0, 0.1)',
                animation: 'pass-bounce 0.6s ease-out'
              }}
            >
              <div
                style={{
                  width: '100px',
                  height: '100px',
                  borderRadius: '50%',
                  margin: '0 auto 1.5rem',
                  background: passedPlayer === BLACK ? '#000' : '#fff',
                  border: passedPlayer === BLACK ? 
                    '4px solid #444' : 
                    '4px solid #ddd',
                  display: 'flex',
                  justifyContent: 'center',
                  alignItems: 'center',
                  boxShadow: passedPlayer === BLACK ? 
                    '0 8px 20px rgba(0, 0, 0, 0.4)' : 
                    '0 8px 20px rgba(0, 0, 0, 0.2)'
                }}
              >
                <svg 
                  width="50" 
                  height="50" 
                  viewBox="0 0 24 24" 
                  fill="none" 
                  stroke={passedPlayer === BLACK ? "white" : "black"} 
                  strokeWidth="2.5" 
                  strokeLinecap="round" 
                  strokeLinejoin="round"
                >
                  <path d="M5 12h14"></path>
                </svg>
              </div>
              
              <div
                style={{
                  fontSize: '1.8rem',
                  fontWeight: '600',
                  margin: '0.5rem 0',
                  color: passedPlayer === BLACK ? '#fff' : '#333',
                  fontFamily: "'Segoe UI', sans-serif",
                  opacity: 0.9
                }}
              >
                {passedPlayer === BLACK ? '黒' : '白'}プレイヤー
              </div>
              
              <div
                style={{
                  fontSize: '3rem',
                  fontWeight: '800',
                  margin: '0.5rem 0 1rem',
                  fontFamily: "'Segoe UI', sans-serif",
                  background: passedPlayer === BLACK ?
                    'linear-gradient(45deg, #9d46ff, #6200ea)' :
                    'linear-gradient(45deg, #fff, #ddd)',
                  WebkitBackgroundClip: 'text',
                  WebkitTextFillColor: passedPlayer === BLACK ? 'transparent' : 'initial',
                  letterSpacing: '2px'
                }}
              >
                パス
              </div>
            </div>
          </div>
        );
      };
      
      return (
        <div style={{
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
          padding: '3rem 2rem',
          fontFamily: "'Segoe UI', 'Helvetica', 'Arial', sans-serif",
          maxWidth: '1200px',
          margin: '0 auto',
          minHeight: '100vh',
          background: BACKGROUND
        }}>
          <h1 style={{ 
            fontSize: '2.8rem', 
            fontWeight: '800', 
            color: PRIMARY, 
            marginBottom: '1rem',
            textAlign: 'center',
            letterSpacing: '1px',
            position: 'relative'
          }}>
            Reversis
            <span style={{
              position: 'absolute',
              bottom: '-10px',
              left: '50%',
              transform: 'translateX(-50%)',
              width: '80px',
              height: '4px',
              background: `linear-gradient(90deg, ${PRIMARY_LIGHT}, ${PRIMARY})`,
              borderRadius: '2px'
            }}></span>
          </h1>
          
          <p style={{
            fontSize: '1.1rem',
            color: TEXT_SECONDARY,
            marginBottom: '2.5rem',
            textAlign: 'center',
            maxWidth: '600px'
          }}>
            古典的な戦略ボードゲームで対戦相手と対戦しましょう
          </p>
          
          {renderGameModeSelector()}
          
          <div style={{
            display: 'flex',
            flexDirection: 'row',
            justifyContent: 'center',
            alignItems: 'flex-start',
            gap: '2.5rem',
            position: 'relative',
            width: '100%',
            flexWrap: 'wrap'
          }}>
            <div style={{
              animation: `elegant-fade-in ${TRANSITION_NORMAL}`,
              boxShadow: SHADOW_LARGE
            }}>
              {renderBoard()}
            </div>
            
            <div style={{
              display: 'flex',
              flexDirection: 'column',
              gap: '1.2rem'
            }}>
              {renderGameInfo()}
              {renderNoMoves()}
              {renderThinkingIndicator()}
            </div>
          </div>
          
          <div style={{
            marginTop: '3rem',
            textAlign: 'center',
            color: TEXT_SECONDARY,
            fontSize: '0.9rem'
          }}>
          © 2025 Reversis - All Rights Reserved.
          </div>
          
          {renderGameResult()}
          {renderPassAnimation()}
        </div>
      );
    };
    
    // ルート要素にレンダリング
    const rootElement = document.getElementById("root");
    ReactDOM.createRoot(rootElement).render(<OthelloGame />);
  </script>
</body>
</html>